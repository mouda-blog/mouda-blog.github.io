---
title: 백엔드에서 채팅 기능을 구현한 과정 
date: YYYY-MM-DD HH:MM:SS +09:00
categories: [안나]
tags:
  [
    채팅, Polling
  ]
---

## 기획 의도

모임을 쉽게 만들기 위한 모우다 서비스에서는 채팅 기능을 도입하였습니다.

모임을 만들었을 때 일일이 번호를 받아서 채팅방을 만드는 경험을 한 적이 있지 않았나요? 모임을 구성한 사람들끼리 채팅방을 서비스 내에서 만들 수 있다면 모임을 만드는 장벽이 낮춰질 것이라 예상하였어요.

채팅 기능을 만들기 위해 주어진 시간은 약 4일 정도에요. 응애 개발자 두 명이서 채팅 기능을 만들 수 있을까요?

응애 .. 🐣

## 채팅 기능을 구현하는 방법

채팅 기능이 다른 기능을 구현하는 것보다 까다로운 이유는 **실시간성**이라는 특징 때문이에요.

호기가 안나에게 채팅을 보낸 상황을 가정해봅시다.

![image](https://github.com/user-attachments/assets/98244c08-80c1-463e-85f1-d4a93772b2d4)


호기가 서버에 채팅을 저장하면 안나가 이를 조회하는, 단순한 게시글 업로드 및 조회 방식을 떠올려볼 수 있겠죠. 하지만 안나는 호기가 언제 서버에 채팅 데이터를 등록했는 지 모르는 상태입니다. 따라서 언제 서버에서 채팅을 조회할 지도 모를거에요.

따라서 안나는 없을지도 모르는 채팅 데이터를 받기 위해 계속 서버에 데이터를 요청해야 합니다.

클라이언트가 서버와 통신할 때 사용하는 HTTP 프로토콜은 기본적으로 상태를 유지하지 않는 (stateless) 프로토콜이기 때문이죠.

따라서 실시간으로 데이터를 전달받기 위해서는 클라이언트가 서버에게 지속적으로 새로운 데이터를 요청해야 하는데, 이런 방식을 **폴링 (polling)** 이라고 해요.

폴링 방식은 불필요한 데이터 요청으로 서버에 부하를 일으킬 수 있지만, 우리가 익히 알고 있는 HTTP 요청 응답 방식을 사용하기 때문에 구현에 용이합니다.

그래서 우리는 이렇게 **일단 구현해볼 수 있는 가장 간단한 방식**으로 채팅 기능을 구현하고 주기를 조절하며 모니터링해보기로 결정하였습니다.

## 채팅 기능을 구현해보기

채팅 기능을 구현하기 위해 어떤 기능이 필요할까요?

-   채팅 데이터를 서버에 저장하는 기능
-   채팅 데이터를 서버에서 조회하는 기능

### 채팅을 보내는 기능

```java
	public void createChat(ChatCreateRequest chatCreateRequest, Member member) {
		Moim moim = findMoimByMoimId(chatCreateRequest.moimId());
		findChamyoByMoimIdAndMemberId(chatCreateRequest.moimId(), member.getId());

		Chat chat = chatCreateRequest.toEntity(moim, member);
		chatRepository.save(chat);
	}

```

채팅을 보내는 기능은 간단합니다. 채팅 데이터를 데이터베이스에 한 행 추가해주기만 하면 되거든요. 이 부분은 추가 설명 없이 넘어가겠습니다.

### 채팅을 조회하는 기능

클라이언트는 폴링 방식으로 서버에 채팅을 조회하는 API 를 요청합니다.

항상 모든 채팅을 전부 조회한다면 응답 본문에 너무 많은 데이터가 담길 것 같아, **최근에 조회한 채팅의 마지막 아이디**를 입력 받아 그 이후의 데이터만 전송받기로 하였습니다.

```java
	@Query("SELECT c FROM Chat c WHERE c.moim.id = :moimId AND c.id > :recentChatId")
	List<Chat> findAllUnloadedChats(@Param("moimId") long moimId, @Param("recentChatId") long recentChatId);

```

이 기능을 통해 채팅방에 접속해있는 상태에서 최근 채팅 이후에 새로 추가된 채팅 데이터를 지속적으로 불러올 수 있습니다. 😉

![image](https://github.com/user-attachments/assets/ad029c7e-a210-4398-8d64-570581eaaf57)

채팅 한 개를 보내면 그 채팅 아이디를 파라미터에 담아서 지속적으로 조회 요청을 보내는 것을 볼 수 있습니다. 😊

이렇게 두 가지 API를 구현했다면 기본적인 채팅은 동작이 가능합니다. 채팅과 관련된 추가적인 기능을 살펴볼게요.

### 읽지 않은 채팅 개수를 계산하는 기능

채팅방 내부에서 폴링 방식으로 채팅을 조회한다고 했습니다. 하지만 채팅방을 벗어나면 어떨까요?

초기 설계에서 채팅방 목록을 조회하는 화면에서는  폴링 방식이 이루어지지 않습니다.

![image](https://github.com/user-attachments/assets/976048bd-a55b-400b-816d-9124c7e4dca2)


하지만 채팅방 목록에서는 읽지 않은 채팅 개수를 계산하는 기능이 있는데, 지속적으로 서버에 저장되고 있는 채팅을 조회해야만 채팅 개수가 늘어날 수 있겠죠.

![image](https://github.com/user-attachments/assets/0cf97d1b-586f-4334-ad73-e4ac84bf5395)

여기에도 어쩔 수 없이 폴링을 도입하였습니다. 실시간으로 변하는 채팅 개수 데이터를 목록에서 표시하기 위한 선택이었어요. 사용자가 **채팅방에서 마지막으로 읽은 채팅 아이디**를 서버에게 보내줍니다. 이 시점은 채팅방에서 뒤로 가기를 누르거나, 브라우저 창을 닫았을 때에 해당합니다.

그럼 서버는 마지막으로 읽은 채팅 아이디와 현재 서버에 마지막으로 저장된 채팅 아이디의 **차이** 값을 활용해 읽지 않은 댓글 개수를 반환해줍니다.

참고로 클라이언트는 채팅방 목록 화면에서 **마지막으로 읽은 채팅**을 알 수 없습니다. 그래서 채팅방 화면을 나가거나 브라우저 창을 닫을 때 이 값을 서버에게 보내주어 저장하게끔 합니다. 그럼 서버는 저장된 값을 조회해 댓글 개수를 카운트 하면 되겠죠.

![image](https://github.com/user-attachments/assets/88d3d4db-13e7-4ec2-9b7a-7fbb92fd50fb)

이 API가 해당 기능을 구현한 것이 되겠습니다. 👍

## 성능 테스트

이렇게 폴링 방식으로 만든 채팅 기능이 과연 여러 사용자가 있을 때에도 잘 작동할 지 궁금해졌습니다. 0.1초마다 서버에게 요청을 보내는 경우 서버에서 병목 현상이 발생할 수 있기 때문이죠.

이 병목 현상의 원인을 파악하기 위해서는 어떤 지표를 활용하여 모니터링 해야 할까요 ?

-   CPU 사용률
-   메모리 사용률
-   네트워크 I/O

사실 이 부분에서는 이해도가 부족하기 때문에 추가적인 공부가 필요할 것 같아요. 성능이 느려질만한 유의미한 트래픽이 몰리지도 않는 상황이구요. 나중에 때가 왔을 때, 아래 고민들을 통해 모니터링 해보면 좋을 것 같습니다 .😊

-   어떻게 서버가 부하를 받을 수 있도록 테스트할 수 있을까?
-   어떻게 지표를 분석해서 성능 상의 문제를 확인할 수 있을까?

## 다른 방법으로 구현한다면 .. 🤔

### 롱 폴링 (Long polling)

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/7eaea7db-7d9d-4a0d-803d-bf18f474ae30/74ee583e-a652-4145-9654-1608e6742b6a/Untitled.png)

롱 폴링 방식은 아래 흐름으로 요청을 처리합니다.

1.  서버에게 요청을 보낸다.
2.  서버는 보낼 새로운 메시지를 받을 때까지 연결을 유지합니다.
3.  메시지가 생기면 서버는 이와 함께 요청에 응답합니다.
4.  클라이언트는 응답을 받은 즉시 새로운 요청을 보냅니다.

롱 폴링을 사용하면 새로운 데이터가 발생할 때까지 응답을 보내지 않고, 클라이언트도 새로운 요청을 보내지 않기 때문에 서버의 부담이 줄게 됩니다.

하지만 하나의 요청에 대해 오랜 기간 서버가 커넥션을 할당하고 있다면 다수의 클라이언트 요청이 들어왔을 때 부하가 발생할 수 있죠. 폴링보다 구현이 복잡하다는 점에서 우리 서비스는 당장 롱 폴링부터 적용하지는 않았습니다.

### 웹소켓

HTTP 프로토콜이 단방향 통신이기 때문에 서버가 클라이언트에게 통신할 수 없다는 것이 실시간 통신에서 폴링을 도입하게 된 주요 이유입니다.

만약에 서버가 클라이언트에게 통신을 시도할 수 있다면 어떨까요? 웹 소켓은 양방향 통신이 가능한 프로토콜을 사용하여 서버로부터 이벤트 기반 응답을 받는다. 즉 클라이언트는 지속적인 요청을 보내지 않더라도 새로운 채팅이 저장되었을 때 서버로부터 응답을 받을 수 있다. 😁
